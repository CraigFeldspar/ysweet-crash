export type RoomCreationResult = {
    doc_id: string
}

/**
 * Create a document with a random name generated by the server.
 * 
 * @returns 
 */
export async function createDoc(): Promise<RoomCreationResult> {
    const result = await fetch('http://127.0.0.1:8080/doc/new', {
        method: 'POST',
        cache: 'no-store',
    })
    if (!result.ok) {
        throw new Error(`Failed to create doc: ${result.status} ${result.statusText}`)
    }
    return result.json()
}

/**
 * Return a connection key for a document.
 * If no docId is provided, a new document is created, equivalent to calling
 * `createDoc()` followed by `getConnectionKey()`.
 * 
 * @param docId 
 * @returns 
 */
export async function getOrCreateDoc(docId?: string): Promise<ConnectionKey> {
    if (!docId) {
        let room = await createDoc()
        docId = room.doc_id
    }

    return await getConnectionKey(docId, {})
}

export type AuthDocRequest = {
    authorization?: "none" | "readonly" | "full",
    user_id?: string,
    metadata?: Record<string, any>,
}

export type ConnectionKey = {
    base_url: string,
    doc_id: string,
}

/**
 * Return a connection key for a document.
 * 
 * @param docId
 * @param request
 * @returns
 */ 
export async function getConnectionKey(docId: string, request: AuthDocRequest): Promise<ConnectionKey> {
    const result = await fetch(`http://127.0.0.1:8080/doc/${docId}/auth`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(request),
        cache: 'no-store',
    })
    if (!result.ok) {
        throw new Error(`Failed to auth doc ${docId}: ${result.status} ${result.statusText}`)
    }
    return result.json()
}
